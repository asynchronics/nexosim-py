"""Type-related utilities.

This module provides facilities to conveniently build Python counterparts to
Rust's `struct` and `enum` types that can be (de)serialized as events, requests
or replies within a [`Simulation`][nexosim.Simulation].

## Struct-like classes

Rust distinguishes between regular `struct` types (with named fields), unit
`struct` types and tuple `struct` types. Because these types are serialized
differently, it is important to preserve this distinction on the Python side.

Regular Rust `struct` types can be directly represented in Python with
dataclasses, using e.g. the standard `@dataclasses.dataclass` decorator or the
`@define` decorator from the `attrs` package.

Unit `struct` types are in turn represented by empty classes deriving from the
[UnitType][nexosim.types.UnitType] class. Likewise, tuple `struct` types are
represented by deriving from the `TupleType` class.

For instance, these Rust `struct` types:

```rust
struct MyRegularStruct {
    foo: f64,
    bar: (u32, String),
}

struct MyUnitStruct;

struct MyTupleStruct(u32, String);
```

can be defined on the Python side with:

```py
from dataclasses import dataclass

from nexosim.types import UnitType, TupleType

@dataclass
class MyRegularStruct:
    foo: int
    bar: (int, str)

class MyUnitStruct(UnitType): ... # no implementation needed

class MyTupleStruct(TupleType[int, str]): ... # no implementation needed
```

## Enum-like classes

Rust `enum` types are represented by classes decorated with
[`@enumclass`][nexosim.types.enumclass], defining the variants as nested
classes.

Unit-like, tuple-like and struct-like variants are defined in exactly the
same way as [`struct`-like classes][nexosim.types--struct-like-classes].

Warning:
    Classes decorated with [`@enumclass`][nexosim.types.enumclass] implicitely
    define an `enum` type but are not the `enum` type itself.

    Rather, the `enum` type is represented by a Python `Union` of the nested
    variant types, which for convenience is automatically generated by the
    `@enumclass` decorator and exposed as the `type` class variable.

For instance, this Rust `enum`:

```rust
enum MyEnum {
    MyUnitVariant,
    MyTupleVariant(i32, String),
    MyStructVariant { foo: f64, bar: u64 },
}
```

can be defined on the Python side with:

```py
from dataclasses import dataclass
from nexosim.types import enumclass, UnitType, TupleType

@enumclass
class MyEnum:
    class MyUnitVariant(UnitType): ...

    class MyTupleVariant(TupleType[int, str]): ...

    @dataclass
    class MyStructVariant:
        foo: float
        bar: int

    # The following class variable is automatically generated:
    #
    # type = MyUnitVariant | MyTupleVariant | MyStructVariant
```

If the above `enum` were in turn used within a Rust `struct`:

```rust
struct MyComposedStruct {
    s: String,
    e: MyEnum,
}
```

then such `struct` could be represented in Python by:

```py
@dataclass
class MyComposedStruct:
    s: str
    e: MyEnum.type # <- the actual union type is given by the `type` field
```

## Type checking enums

Because the `type` field is dynamically added to the `enum` class definition by
the [`@enumclass`][nexosim.types.enumclass] decorator, it is invisible to type
checkers. This would in particular cause type checkers to complain in the
earlier declaration of `MyComposedStruct`, even though its definition is valid
and usable for serialization and deserialization purposes.

To prevent such false positives, you may elect to explicitly set the `type`
field, for instance:

```py
@enumclass
class MyEnum:
    class MyUnitVariant(UnitType): ...

    class MyTupleVariant(TupleType[int, str]): ...

    @dataclass
    class MyStructVariant:
        foo: float
        bar: int

    type = MyUnitVariant | MyTupleVariant | MyStructVariant
```

In order to prevent mistakes, the [`@enumclass`][nexosim.types.enumclass]
decorator raises an exception if an explicitly-set `type` field is not
equivalent to the auto-generated one.


## Pattern matching

Tuple- and struct-like `enum` variants are dataclasses, either because they are
explicitly marked as such (struct-like variants) or because they derive from
dataclasses (tuple-like variants). This implies that `enum`s can be
structurally matched.

This is an example of pattern matching for the previously-defined `MyEnum`:

```py
def print_my_enum(my_enum):
    match my_enum:
        case MyEnum.MyUnitVariant():
            print("MyUnitVariant")
        case MyEnum.MyTupleVariant(number, string):
            print(f"MyTupleVariant({number}, {string})")
        case MyEnum.MyStructVariant(foo=x, bar=y):
            print(f"MyStructVariant(foo={x}, bar={y})")
        case _:
            raise RuntimeError("unexpected enum variant")
```

[Explicitly setting the `type` field][nexosim.types--type-checking-enums]
additionally enables exhaustiveness checking. For instance, if the `type` field
is explicitly set in `MyEnum`'s definition, the missing case in the following
code can be caught by the type checker:

```py
def my_enum_discriminant(my_enum: MyEnum.type) -> int:
    match my_enum: # ERROR: function does not return `int` on all code paths
        case MyEnum.MyUnitVariant():
            return 0
        case MyEnum.MyTupleVariant(_):
            return 1
```
"""

import dataclasses
import inspect
import typing
import typing_extensions

from ._config import cbor2_converter as _cbor2_converter

_T = typing.TypeVar("_T")
_Args = typing_extensions.TypeVarTuple("_Args")


def enumclass(cls: type[_T]) -> type[_T]:
    """Class decorator that marks a class as the definition of a Rust-like
    `enum`.

    Note that the decorated class is not the `enum` type itself: the Python
    `Union` of all variants that actually represents the `enum` is generated by
    this decorator and exposed as the `type` class variable.
    """
    variants = {name: ty for name, ty in cls.__dict__.items() if inspect.isclass(ty)}

    # Custom serialization hooks for enum variants.
    for name, ty in variants.items():
        if issubclass(ty, UnitType):
            hook = _variant_unstructure_hook(name, _unit_unstructure_hook)
        elif hasattr(ty, "_tuple_type"):
            hook = _variant_unstructure_hook(name, _tuple_unstructure_hook)
        else:
            hook = _variant_unstructure_hook(name, _struct_unstructure_hook)

        _cbor2_converter.register_unstructure_hook(ty, hook)

    # Infer the union type and assign it to `cls.type`.
    ty_iter = iter(variants.values())
    try:
        ty = next(ty_iter)
    except StopIteration:
        raise ValueError("enums must contain at least one variant")

    for t in ty_iter:
        ty = typing.Union[t, ty]  # type: ignore

    if hasattr(cls, "type"):
        if getattr(cls, "type") != ty:
            raise TypeError(
                "the explicitly provided 'type' field does not match the enum variants"
            )
    else:
        setattr(cls, "type", ty)

    # Custom deserialization hook.
    def structure_enum_hook(d: typing.Any, t: object):  # type: ignore
        if isinstance(d, dict):
            try:
                (ty_name,) = d  # type: ignore
                (ty_unstruct,) = d.values()  # type: ignore
            except ValueError:
                raise ValueError(
                    "enum structuring expects a string or a single-entry dictionary"
                )
        else:
            if not isinstance(d, str):
                raise ValueError(
                    "enum structuring expects a string or a single-entry dictionary"
                )

            ty_name = d
            ty_unstruct = None

        try:
            ty = variants[ty_name]
        except KeyError:
            raise ValueError(
                "could not match unstructured data to a valid enum variant"
            )

        return _cbor2_converter.structure(ty_unstruct, ty)

    _cbor2_converter.register_structure_hook(ty, structure_enum_hook)

    return cls


def _variant_unstructure_hook(
    name: str, hook: typing.Callable[[typing.Any], typing.Any]
):
    def inner(e: typing.Any) -> typing.Any:
        e_unstruct = hook(e)

        return {name: e_unstruct}

    return inner


def _unit_unstructure_hook(e: typing.Any) -> typing.Any:  # type: ignore
    return None


def _tuple_unstructure_hook(e: typing.Any) -> typing.Any:  # type: ignore
    try:
        e_instruct = [
            _cbor2_converter.unstructure(getattr(e, field.name))
            for field in dataclasses.fields(e)
        ]
        if len(e_instruct) == 1:
            e_instruct = e_instruct[0]

        return e_instruct

    except TypeError:
        raise ValueError("tuple-like types must expose a dataclass-like interface")


def _struct_unstructure_hook(e: typing.Any) -> typing.Any:  # type: ignore
    try:
        return {
            field.name: _cbor2_converter.unstructure(getattr(e, field.name))
            for field in dataclasses.fields(e)
        }
    except TypeError:
        raise ValueError("struct types must expose a dataclass-like interface")


@typing_extensions.dataclass_transform()
def tupleclass(cls: typing.Type[_T]) -> typing.Type[_T]:
    """Decorator that marks a class as a tuple-like type.

    This automatically makes the class a dataclass.
    """

    # Tuple struct pretty-printing.
    def repr(s):
        r = tuple(getattr(s, field.name) for field in dataclasses.fields(cls))  # type: ignore
        if len(r) == 1:
            return "{}({})".format(s.__class__.__qualname__, r[0])

        return "{}{}".format(s.__class__.__qualname__, r)

    setattr(cls, "__repr__", repr)

    # Make this class a dataclass and mark it as a tuple type.
    cls = dataclasses.dataclass(cls)
    setattr(cls, "_tuple_type", None)

    # Register the serialization hook.
    _cbor2_converter.register_unstructure_hook(cls, _tuple_unstructure_hook)

    # Register the deserialization hook.
    #
    # Note that zero-arity deserialization works by default since the class is a
    # dataclass.
    arity = len(dataclasses.fields(cls))  # type: ignore
    if arity == 1:
        def structure_hook(d, t):
            (ty,) = typing.get_args(t.__orig_bases__[0])  # type: ignore

            return t(_cbor2_converter.structure(d, ty))

        _cbor2_converter.register_structure_hook(cls, structure_hook)
    elif arity > 1:
        def structure_hook(d, t):
            ty_list = typing.get_args(t.__orig_bases__[0])
            args = [_cbor2_converter.structure(di, ty) for di, ty in zip(d, ty_list)]

            return t(*args)

        _cbor2_converter.register_structure_hook(cls, structure_hook)

    return cls


class UnitType:
    """Base class for unit-like types."""

    __unit_type__ = None

    def __repr__(self):
        return self.__class__.__qualname__


_cbor2_converter.register_structure_hook(UnitType, lambda d, t: t())
_cbor2_converter.register_unstructure_hook(UnitType, _unit_unstructure_hook)

class MetaTupleType(type):
    """Metaclass for constructing TupleType classes.
    
    Adds fields based on the class' type annotations, by overwriting 
    the field annotations.

    The metaclass leaves the new class unchanged, if it directly extends 
    `typing.Generic`.
    """
    def __new__(
            mcs,
            name: str,
            bases: tuple[type, ...],
            namespace: dict[str, typing.Any],
            **kwargs: typing.Any
        ):

        if typing.Generic in bases:
            return super().__new__(mcs, name, bases, namespace, **kwargs)

        if "__orig_bases__" in namespace:
            ty_list = typing.get_args(namespace["__orig_bases__"][0])
            namespace["__annotations__"] = {f"_{i}": ty for i, ty in enumerate(ty_list)}

        return tupleclass(super().__new__(mcs, name, bases, namespace, **kwargs))

class TupleType(typing.Generic[*_Args], metaclass=MetaTupleType):
    """Base class for tuple-like classes."""
